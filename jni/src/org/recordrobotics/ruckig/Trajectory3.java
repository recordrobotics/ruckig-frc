package org.recordrobotics.ruckig;

import java.util.Arrays;
import java.util.OptionalDouble;

import org.recordrobotics.ruckig.jni.RuckigJNI;

/**
 * The trajectory generated by the Ruckig algorithm.
 */
public class Trajectory3 {

    long handle;

    Trajectory3(long handle) {
        this.handle = handle;
    }

    /**
     * The kinematic state of the robot at a specific time.
     * 
     * @param position     The position of the robot in each degree of freedom
     *                     (DoF).
     * @param velocity     The velocity of the robot in each DoF.
     * @param acceleration The acceleration of the robot in each DoF.
     */
    public record KinematicState(double[] position, double[] velocity, double[] acceleration) {
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            KinematicState that = (KinematicState) obj;
            return Arrays.equals(position, that.position)
                    && Arrays.equals(velocity, that.velocity)
                    && Arrays.equals(acceleration, that.acceleration);
        }

        @Override
        public int hashCode() {
            int result = Arrays.hashCode(position);
            result = 31 * result + Arrays.hashCode(velocity);
            result = 31 * result + Arrays.hashCode(acceleration);
            return result;
        }

        @Override
        public String toString() {
            return "KinematicState{" + "position="
                    + Arrays.toString(position) + ", velocity="
                    + Arrays.toString(velocity) + ", acceleration="
                    + Arrays.toString(acceleration) + '}';
        }
    }

    /**
     * Information about the position extrema
     * 
     * @param min   The minimum position.
     * @param max   The maximum position.
     * @param t_min The time at which the minimum position occurs.
     * @param t_max The time at which the maximum position occurs.
     */
    public record Bound(double min, double max, double t_min, double t_max) {
    }

    /**
     * Get the kinematic state at a given time
     * 
     * @param time The time at which to get the kinematic state.
     */
    public KinematicState atTime(double time) {
        double[] vars = RuckigJNI.trajectoryAtTime(handle, time);
        double[] position = new double[3];
        double[] velocity = new double[3];
        double[] acceleration = new double[3];

        System.arraycopy(vars, 0, position, 0, 3);
        System.arraycopy(vars, 3, velocity, 0, 3);
        System.arraycopy(vars, 6, acceleration, 0, 3);

        return new KinematicState(position, velocity, acceleration);
    }

    /**
     * Get the duration of the (synchronized) trajectory
     */
    public double getDuration() {
        return RuckigJNI.trajectoryDuration(handle);
    }

    /**
     * Get the min/max values of the position for each DoF
     */
    public Bound[] getPositionExtrema() {
        double[] bounds = RuckigJNI.trajectoryPositionExtrema(handle);
        Bound[] positionBounds = new Bound[3];
        for (int i = 0; i < 3; i++) {
            positionBounds[i] = new Bound(bounds[i * 4], bounds[i * 4 + 1], bounds[i * 4 + 2], bounds[i * 4 + 3]);
        }
        return positionBounds;
    }

    /**
     * Get the time that this trajectory passes a specific position of a given DoF
     * the first time
     * 
     * @param dof      The degree of freedom (DoF) to check.
     * @param position The position to check for.
     * @return An OptionalDouble containing the time at which the position is first
     *         reached, or an empty OptionalDouble if the position is never reached.
     */
    public OptionalDouble getFirstTimeAtPosition(int dof, double position) {
        return getFirstTimeAtPosition(dof, position, 0.0);
    }

    /**
     * Get the time that this trajectory passes a specific position of a given DoF
     * the first time
     * 
     * @param dof        The degree of freedom (DoF) to check.
     * @param position   The position to check for.
     * @param time_after The time after which to start looking for the position.
     * @return An OptionalDouble containing the time at which the position is first
     *         reached, or an empty OptionalDouble if the position is never reached.
     */
    public OptionalDouble getFirstTimeAtPosition(int dof, double position, double time_after) {
        double time = RuckigJNI.trajectoryFirstTimeAtPosition(handle, dof, position, time_after);
        return time != Double.MIN_VALUE ? OptionalDouble.of(time) : OptionalDouble.empty();
    }
}
